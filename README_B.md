# README B: 显式导航 / 对抗意图解耦 + 开关控制（Adversarial Intent Factorization）

## 1. 目标与动机

本实现验证一种 **显式意图解耦的对抗导航框架**，将：

* “去目标（navigation）”
* “对抗他人（adversarial interaction）”

视为两种**本质不同的决策意图**，并通过结构化潜变量与开关机制进行控制。

核心假设：

> 对抗行为不是持续存在的策略噪声，而是仅在交互条件满足时被激活的高层决策。

---

## 2. 方法概述

### 2.1 潜变量设计

* `z_nav`：导航意图潜变量（目标导向）
* `z_adv`：对抗意图潜变量（交互策略）
* `g ∈ {0,1}`：对抗开关（是否处于交互状态）

组合形式：

```
z = [ z_nav , g · z_adv ]
```

---

## 3. 架构组成

* **Navigation Encoder `E_nav`**
  输入：观测 + 目标
  输出：`z_nav`

* **Adversarial Encoder `E_adv`**
  输入：观测 + 他人状态（或交互特征）
  输出：`z_adv`

* **Interaction Gate `G`**
  输入：交互特征（距离、TTC 等）
  输出：`g`

* **Diffusion Trajectory Decoder `D_diff`**
  条件：`z_nav` + `g·z_adv`

---

## 4. 训练逻辑

### 4.1 数据要求

* 普通导航数据（无交互 / 弱交互）
* 含交互或对抗行为的数据（可合成）

### 4.2 训练策略

* `z_nav` 始终参与训练
* `z_adv` **仅在 g=1 的样本中激活**
* 强制模型在 `g=0` 时退化为纯导航策略

### 4.3 损失设计

* 基础 diffusion 去噪损失
* 对抗样本中：交互相关奖励 / 代价
* 可选：对 `z_adv` 的幅度或影响范围约束

---

## 5. 推理与对抗控制

### 5.1 推理流程

1. 根据当前场景计算交互条件 → `g`
2. 若 `g=0`：

   * 使用 `z_nav` 生成标准导航轨迹
3. 若 `g=1`：

   * 固定 `z_nav`
   * 调节或优化 `z_adv` 以生成不同对抗风格

### 5.2 对抗生成方式

* 扫描 `z_adv` 潜空间
* 梯度优化 `z_adv`
* 固定导航目标不变

---

## 6. Demo 实验建议

### 可行性验证（Stage 1）

* `g=0` vs `g=1` 行为对比
* 固定 `z_nav`，改变 `z_adv`

### 性能验证（Stage 2）

* 在相同起终点下：

  * 成功率保持情况
  * 对他人轨迹的影响程度

---

## 7. 方法优势与定位

**优势**：

* 语义清晰、可解释
* 对抗行为可控、可开关
* 适合系统性生成 worst-case 交互

**定位**：

* 不是学习“整体策略风格”
* 而是建模“条件性对抗决策”
